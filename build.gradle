import com.bmuschko.gradle.docker.tasks.DockerClient
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.github.dockerjava.api.exception.DockerException
import groovy.json.JsonSlurper

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.aries:docker-java-shaded:3.1.0-rc-5'
    }
}

plugins {
    id 'application'
    id 'checkstyle'
    id 'com.bmuschko.docker-remote-api' version '4.0.4'
}

group 'org.javacord'
description 'The Javacord Bot'

sourceCompatibility = 1.8
mainClassName = 'org.javacord.bot.Main'
defaultTasks 'build'

repositories {
    jcenter()
    maven { url 'https://jitpack.io' }
}

ext {
    versions = [
            checkstyle: '8.14',
            javacord  : '3.1.1',
            sdcf4j    : 'v1.0.10',
            okhttp    : '3.9.1',
            jackson   : '2.9.3',
            log4j     : '2.17.1'
    ]
}

dependencies {
    implementation "org.javacord:javacord:${versions.javacord}"
    implementation "de.btobastian.sdcf4j:sdcf4j-javacord:${versions.sdcf4j}"
    implementation "de.btobastian.sdcf4j:sdcf4j-core:${versions.sdcf4j}"
    implementation "com.squareup.okhttp3:okhttp:${versions.okhttp}"
    implementation "com.fasterxml.jackson.core:jackson-databind:${versions.jackson}"
    implementation "org.apache.logging.log4j:log4j-api:${versions.log4j}"
    implementation "org.apache.logging.log4j:log4j-jul:${versions.log4j}"

    runtimeOnly "org.apache.logging.log4j:log4j-core:${versions.log4j}"
    runtimeOnly "org.apache.logging.log4j:log4j-slf4j-impl:${versions.log4j}"
}

tasks.withType(JavaCompile) {
    options.encoding 'UTF-8'
    if (JavaVersion.current().java9Compatible) {
        afterEvaluate {
            options.compilerArgs << '--release' << platform.targetCompatibility.majorVersion
        }
    }
}

checkstyle {
    toolVersion versions.checkstyle
    maxWarnings 0
}

startScripts {
    defaultJvmOpts = ['-Dlog4j.configurationFile=%APP_HOME%/config/log4j2.xml']
    doLast {
        unixScript.text = unixScript.text.replace('%APP_HOME%', '$APP_HOME')
        windowsScript.text = windowsScript.text.replace('%%APP_HOME%%', '%APP_HOME%')
    }
}

distributions {
    main {
        contents {
            from ('src/main/resources/log4j2.xml') {
                into 'config'
            }
        }
    }
}

task assembleDockerContext(type: Sync) {
    from distTar
    from 'Dockerfile'
    into "$buildDir/docker"
}

task buildDockerImage(type: DockerBuildImage, dependsOn: assembleDockerContext) {
    inputDir = file("$buildDir/docker")
    tag = project.name
}

task updateDockerService(type: DockerClient, dependsOn: buildDockerImage) {
    onNext {
        try {
            // check whether docker engine is in swarm mode and a manager
            inspectSwarmCmd().exec()
        } catch (DockerException de) {
            // initialize new swarm if not in swarm mode or else re-throw
            if (new JsonSlurper().parseText(de.message).message.contains('This node is not a swarm manager')) {
                throw new RuntimeException("This node is not a swarm manager, " +
                        "please make it one and create a service with name '$project.name'", de)
            } else {
                throw de
            }
        }

        // update the service
        def services = listServicesCmd().withNameFilter([project.name]).exec()
        if (services) {
            def service = services[0]
            def taskTemplate = service.spec.taskTemplate
            taskTemplate = taskTemplate.withForceUpdate(taskTemplate.forceUpdate + 1)
            updateServiceCmd(project.name, service.spec.withTaskTemplate(taskTemplate))
                    .withVersion(service.version.index).exec()
        } else {
            throw new RuntimeException("Service with name '$project.name' was not found, please create it first")
        }
    }
}
